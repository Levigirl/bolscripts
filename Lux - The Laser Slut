if myHero.charName ~= "Lux"  or not VIP_USER then return end
local version = 1.0
local AUTOUPDATE = true
local SCRIPT_NAME = "Lux - The Laser Slut"
local SOURCELIB_URL = "https://raw.github.com/TheRealSource/public/master/common/SourceLib.lua"
local SOURCELIB_PATH = LIB_PATH.."SourceLib.lua"
-- thx to klokje and dekaron2
require 'VPrediction'
require 'SOW'
require 'SourceLib'
require 'Collision'
require 'Prodiction'

-- These variables need to be near the top of your script so you can call them in your callbacks.
HWID = Base64Encode(tostring(os.getenv("PROCESSOR_IDENTIFIER")..os.getenv("USERNAME")..os.getenv("COMPUTERNAME")..os.getenv("PROCESSOR_LEVEL")..os.getenv("PROCESSOR_REVISION")))
-- DO NOT CHANGE. This is set to your proper ID.
id = 244

-- CHANGE ME. Make this the exact same name as the script you added into the site!
ScriptName = "Lux"

-- Thank you to Roach and Bilbao for the support!
assert(load(Base64Decode("G0x1YVIAAQQEBAgAGZMNChoKAAAAAAAAAAAAAQIDAAAAJQAAAAgAAIAfAIAAAQAAAAQKAAAAVXBkYXRlV2ViAAEAAAACAAAADAAAAAQAETUAAAAGAUAAQUEAAB2BAAFGgUAAh8FAAp0BgABdgQAAjAHBAgFCAQBBggEAnUEAAhsAAAAXwAOAjMHBAgECAgBAAgABgUICAMACgAEBgwIARsNCAEcDwwaAA4AAwUMDAAGEAwBdgwACgcMDABaCAwSdQYABF4ADgIzBwQIBAgQAQAIAAYFCAgDAAoABAYMCAEbDQgBHA8MGgAOAAMFDAwABhAMAXYMAAoHDAwAWggMEnUGAAYwBxQIBQgUAnQGBAQgAgokIwAGJCICBiIyBxQKdQQABHwCAABcAAAAECAAAAHJlcXVpcmUABAcAAABzb2NrZXQABAcAAABhc3NlcnQABAQAAAB0Y3AABAgAAABjb25uZWN0AAQQAAAAYm9sLXRyYWNrZXIuY29tAAMAAAAAAABUQAQFAAAAc2VuZAAEGAAAAEdFVCAvcmVzdC9uZXdwbGF5ZXI/aWQ9AAQHAAAAJmh3aWQ9AAQNAAAAJnNjcmlwdE5hbWU9AAQHAAAAc3RyaW5nAAQFAAAAZ3N1YgAEDQAAAFteMC05QS1aYS16XQAEAQAAAAAEJQAAACBIVFRQLzEuMA0KSG9zdDogYm9sLXRyYWNrZXIuY29tDQoNCgAEGwAAAEdFVCAvcmVzdC9kZWxldGVwbGF5ZXI/aWQ9AAQCAAAAcwAEBwAAAHN0YXR1cwAECAAAAHBhcnRpYWwABAgAAAByZWNlaXZlAAQDAAAAKmEABAYAAABjbG9zZQAAAAAAAQAAAAAAEAAAAEBvYmZ1c2NhdGVkLmx1YQA1AAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAMAAAADAAAAAwAAAAMAAAAEAAAABAAAAAUAAAAFAAAABQAAAAYAAAAGAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAgAAAAHAAAABQAAAAgAAAAJAAAACQAAAAkAAAAKAAAACgAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAAMAAAACwAAAAkAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAGAAAAAgAAAGEAAAAAADUAAAACAAAAYgAAAAAANQAAAAIAAABjAAAAAAA1AAAAAgAAAGQAAAAAADUAAAADAAAAX2EAAwAAADUAAAADAAAAYWEABwAAADUAAAABAAAABQAAAF9FTlYAAQAAAAEAEAAAAEBvYmZ1c2NhdGVkLmx1YQADAAAADAAAAAIAAAAMAAAAAAAAAAEAAAAFAAAAX0VOVgA="), nil, "bt", _ENV))()
-- Constants --
local ignite, igniteReady = nil, nil
local ts = nil
local VP = nil
local ADC, lowGuy
local eRange
local qRange
local rRange

local enemyHeros = {}
local enemyHerosCount = 0
local useIgnite = true
local tick = nil
local qOff, wOff, eOff, rOff = 0,0,0,0
local abilitySequence = {3,1,2,3,3,4,3,2,3,2,4,2,2,1,1,4,1,1}
local Ranges = { AA = 500 }
local skills = {
	SkillQ = { ready = true, name = "LuxLightBinding", range = 1150, delay = 0.25, speed = 1175.0, width = 80.0 },
	SkillW = { ready = true, name = "", range = 1100, delay = null, speed = null, width = null },
	SkillE = { ready = true, name = "LuxLightStrikeKugel", range = 1100, delay = 0.15, speed = 1300.0, width = 275.0 },
	SkillR = { ready = true, name = "LuxMaliceCannon", range = 3340, delay = 0.7, speed = null, width = 190.0 },
}
--[[ Slots Itens ]]--
local tiamatSlot, hydraSlot, youmuuSlot, bilgeSlot, bladeSlot, dfgSlot, divineSlot = nil, nil, nil, nil, nil, nil, nil
local tiamatReady, hydraReady, youmuuReady, bilgeReady, bladeReady, dfgReady, divineReady = nil, nil, nil, nil, nil, nil, nil

-- champs
Champions = {
    ["Katarina"] = {
    	spells = {
    		["KatarinaR"] = {name = "Death Lotus"}
    	}
    },
    ["Nunu"] = {
    	spells = {
    		["AbsoluteZero"] = {name = "Absolute Zero"}
    	}
    },
    ["Karthus"] = {
    	spells = {
    		["KarthusFallenOne"] = {name = "Requiem"}
    	}
    },
    ["FiddleSticks"] = {
    	spells = {
    		["Crowstorm"] = {name = "Crowstorm"}
    	}
    },
    ["Malzahar"] = {
    	spells = {
    		["AlZaharNetherGrasp"] = {name = "NetherGrasp"}
    	}
    },
    ["Galio"] = {
    	spells = {
    		["GalioIdolOfDurand"] = {name = "Idol of Durand"}
    	}
    },
}

--[[Auto Attacks]]--
local lastBasicAttack = 0
local swingDelay = 0.25
local swing = false

--[[Misc]]--
local lastSkin = 0
local isSAC = false
local isMMA = false
local target = nil
--Credit Trees
function GetCustomTarget()
	ts:update()
	if _G.MMA_Target and _G.MMA_Target.type == myHero.type then return _G.MMA_Target end
	if _G.AutoCarry and _G.AutoCarry.Crosshair and _G.AutoCarry.Attack_Crosshair and _G.AutoCarry.Attack_Crosshair.target and _G.AutoCarry.Attack_Crosshair.target.type == myHero.type then return _G.AutoCarry.Attack_Crosshair.target end
	return ts.target
end
function OnLoad()
	if _G.ScriptLoaded then	return end
	_G.ScriptLoaded = true
	initComponents()
  UpdateWeb(true, ScriptName, id, HWID)
end
function initComponents()
  Prod = ProdictManager.GetInstance()
  ProdQ = Prod:AddProdictionObject(_Q, 1150, 1175, 0.250, 80)    
  qPos = nil
  ProdE = Prod:AddProdictionObject(_E, 1100, 1300, 0.150, 190)  
  ePos = nil
  ProdR = Prod:AddProdictionObject(_R, 3340, math.huge, 0.700, 190)  
  rPos = nil
    -- VPrediction Start
 VP = VPrediction()
   -- SOW Declare
   Orbwalker = SOW(VP)
  -- Target Selector
   ts = TargetSelector(TARGET_LESS_CAST_PRIORITY, 900)
  
 Menu = scriptConfig("Lux - The Laser Slut by SyraX", "luxMA")

   if _G.MMA_Loaded ~= nil then
     PrintChat("<font color = \"#33CCCC\">MMA Search:</font> <font color = \"#fff8e7\"> Got it! MMA loaded Gino </font>")
     isMMA = true
 elseif _G.AutoCarry ~= nil then
      PrintChat("<font color = \"#33CCCC\">SAC Search:</font> <font color = \"#fff8e7\"> Got it! SAC Loaded Gino </font>")
     isSAC = true
 else
     PrintChat("<font color = \"#33CCCC\">SAC/MMA! Not Fount:</font> <font color = \"#fff8e7\"> Loading SOW for The simple guy</font>")
       Menu:addSubMenu("["..myHero.charName.." - Orbwalker]", "SOWorb")
       Orbwalker:LoadToMenu(Menu.SOWorb)
    end
  
 Menu:addSubMenu("["..myHero.charName.." - Combo]", "luxCombo")
    Menu.luxCombo:addParam("combo", "Combo mode", SCRIPT_PARAM_ONKEYDOWN, false, 32)
    Menu.luxCombo:addSubMenu("Q Settings", "qSet")
  Menu.luxCombo.qSet:addParam("useQ", "Use Q in combo", SCRIPT_PARAM_ONOFF, true)
 Menu.luxCombo:addSubMenu("W Settings", "wSet")
  Menu.luxCombo.wSet:addParam("useW", "Use W", SCRIPT_PARAM_ONOFF, false)
 Menu.luxCombo:addSubMenu("E Settings", "eSet")
  Menu.luxCombo.eSet:addParam("useE", "Use E in combo", SCRIPT_PARAM_ONOFF, true)
 Menu.luxCombo:addSubMenu("R Settings", "rSet")
  Menu.luxCombo.rSet:addParam("useR", "Use Smart Ultimate", SCRIPT_PARAM_ONOFF, true)
 
 Menu:addSubMenu("["..myHero.charName.." - Harass]", "Harass")
  Menu.Harass:addParam("harass", "Harass", SCRIPT_PARAM_ONKEYDOWN, false, string.byte("G"))
  Menu.Harass:addParam("useQ", "Use Q in Harass", SCRIPT_PARAM_ONOFF, true)
    Menu.Harass:addParam("useW", "Use W in Harass", SCRIPT_PARAM_ONOFF, false)
   Menu.Harass:addParam("useE", "Use E in Harass", SCRIPT_PARAM_ONOFF, true)
    
 Menu:addSubMenu("["..myHero.charName.." - Laneclear]", "Laneclear")
    Menu.Laneclear:addParam("lclr", "Laneclear Key", SCRIPT_PARAM_ONKEYDOWN, false, string.byte("V"))
  Menu.Laneclear:addParam("useClearQ", "Use Q in Laneclear", SCRIPT_PARAM_ONOFF, true)
 Menu.Laneclear:addParam("useClearW", "Use W in Laneclear", SCRIPT_PARAM_ONOFF, false)
    Menu.Laneclear:addParam("useClearE", "Use E in Laneclear", SCRIPT_PARAM_ONOFF, true)
 
 Menu:addSubMenu("["..myHero.charName.." - Jungleclear]", "Jungleclear")
    Menu.Jungleclear:addParam("jclr", "Jungleclear Key", SCRIPT_PARAM_ONKEYDOWN, false, string.byte("V"))
  Menu.Jungleclear:addParam("useClearQ", "Use Q in Jungleclear", SCRIPT_PARAM_ONOFF, true)
 Menu.Jungleclear:addParam("useClearW", "Use W in Jungleclear", SCRIPT_PARAM_ONOFF, false)
    Menu.Jungleclear:addParam("useClearE", "Use E in Jungleclear", SCRIPT_PARAM_ONOFF, true)
    
     Menu:addSubMenu("["..myHero.charName.." - Prodiction Settings]", "ProdSettings") -- Menu.ProdSettings.SelectProdiction
 -- Menu.selectProdSettings == 1 or 2
	Menu.ProdSettings:addParam("SelectProdiction", "Select Prodiction", SCRIPT_PARAM_LIST, 1, {"Prodiction", "VPrediction"})
 -- Menu.ProdSettings:addParam("OD", "OnDash", SCRIPT_PARAM_ONOFF, false)
  --Menu.ProdSettings:addParam("AD", "AfterDash", SCRIPT_PARAM_ONOFF, false)
 -- Menu.ProdSettings:addParam("AI", "AfterImmobile", SCRIPT_PARAM_ONOFF, false)
  --Menu.ProdSettings:addParam("OI", "OnImmobile ", SCRIPT_PARAM_ONOFF, false)
 -- Menu.ProdSettings.OD
 
 Menu:addSubMenu("["..myHero.charName.." - Additionals]", "Ads")
    Menu.Ads:addParam("autoLevel", "Auto-Level Spells", SCRIPT_PARAM_ONOFF, false)
  --  Menu.Ads:addParam("Shield", "Shield Ally", SCRIPT_PARAM_ONOFF, false)
   Menu.Ads:addParam("Shieldd", "Shiel your self", SCRIPT_PARAM_ONOFF, false)
    Menu.Ads:addParam("NOVA", "Cast second E", SCRIPT_PARAM_ONOFF, false)
   Menu.Ads:addSubMenu("Killsteal", "KS")
   Menu.Ads.KS:addParam("ignite", "Use Ignite", SCRIPT_PARAM_ONOFF, false)
   Menu.Ads.KS:addParam("useR", "Use R", SCRIPT_PARAM_ONOFF, false)
   Menu.Ads.KS:addParam("useE", "Use E", SCRIPT_PARAM_ONOFF, false)
   Menu.Ads.KS:addParam("useQ", "Use Q", SCRIPT_PARAM_ONOFF, false)
   Menu.Ads.KS:addParam("autoQ", "Auto Q", SCRIPT_PARAM_ONOFF, false)
   Menu.Ads.KS:addParam("KSB", "Steal Buffs", SCRIPT_PARAM_ONOFF, false)
  Menu.Ads.KS:addParam("igniteRange", "Minimum range to cast Ignite", SCRIPT_PARAM_SLICE, 470, 0, 600, 0)
  Menu.Ads:addSubMenu("VIP", "VIP")
    Menu.Ads.VIP:addParam("skin", "Use custom skin", SCRIPT_PARAM_ONOFF, false)
  Menu.Ads.VIP:addParam("skin1", "Skin changer", SCRIPT_PARAM_SLICE, 1, 1, 5)
    
 Menu:addSubMenu("["..myHero.charName.." - Target Selector]", "targetSelector")
 Menu.targetSelector:addTS(ts)
    ts.name = "Focus"
  
 Menu:addSubMenu("["..myHero.charName.." - Drawings]", "drawings")
  Menu.drawings:addParam("drawAA", "Draw AA Range", SCRIPT_PARAM_ONOFF, true)
  Menu.drawings:addParam("drawQ", "Draw Q Range", SCRIPT_PARAM_ONOFF, true)
    Menu.drawings:addParam("drawW", "Draw W Range", SCRIPT_PARAM_ONOFF, true)
    Menu.drawings:addParam("drawE", "Draw E Range", SCRIPT_PARAM_ONOFF, true)
    Menu.drawings:addParam("drawR", "Draw R Range", SCRIPT_PARAM_ONOFF, true)
    
 targetMinions = minionManager(MINION_ENEMY, 360, myHero, MINION_SORT_MAXHEALTH_DEC)
  allyMinions = minionManager(MINION_ALLY, 360, myHero, MINION_SORT_MAXHEALTH_DEC)
 jungleMinions = minionManager(MINION_JUNGLE, 360, myHero, MINION_SORT_MAXHEALTH_DEC)
 
 if Menu.Ads.VIP.skin and VIP_USER then
       GenModelPacket("lux", Menu.Ads.VIP.skin1)
     lastSkin = Menu.Ads.VIP.skin1
    end
    
  for i = 1, heroManager.iCount do
    local hero = heroManager:GetHero(i)
      if hero.team ~= myHero.team then
        
        ProdQ:GetPredictionAfterDash(hero, AfterDashFunc)
        ProdQ:GetPredictionAfterImmobile(hero, AfterImmobileFunc)
        ProdR:GetPredictionOnImmobile(hero, OnImmobileFunc)
        
      end
    end
  
 PrintChat("<font color = \"#FA8844\">Lux - The Laser Slut by</font> <font color = \"#FF0740\">SyraX V"..version.."</font>")
end

local objE = nil
local Damage = falsebaloube
function OnTick()
  target = GetCustomTarget()
	targetMinions:update()
	allyMinions:update()
	jungleMinions:update()
	CDHandler()
	KillSteal()
  DamageCalculation()
  OnGapclose(target)
  RDamage()
  
  
  
	if Menu.Ads.VIP.skin and VIP_USER and skinChanged() then
		GenModelPacket("lux", Menu.Ads.VIP.skin1)
		lastSkin = Menu.Ads.VIP.skin1
	end
  
  -- Make a callback which continuesly keeps track of the predicted pos from the callback to see what it does.
  if ValidTarget(target) then
    ProdQ:GetPredictionCallBack(target, GetQPos)
    ProdE:GetPredictionCallBack(target, GetEPos)
    ProdR:GetPredictionCallBack(target, GetRPos)
  else
    qPos = nil
    ePos = nil
    rPos = nil
  end
  
  
  -- CasMenu.luxCombo.qSet.useQ

    
  -- Enable/Disable certain callbacks when turned on/off by the menu.
    for i = 1, heroManager.iCount do
        local hero = heroManager:GetHero(i)
        if hero.team ~= myHero.team then
         
            
            if Menu.ProdSettings.AD then
                ProdQ:GetPredictionAfterDash(hero, AfterDashFunc)
            
            else
                ProdQ:GetPredictionAfterDash(hero, AfterDashFunc, false)
               
            end
            
            if Menu.ProdSettings.AI then
                ProdQ:GetPredictionAfterImmobile(hero, AfterImmobileFunc)
               
            else
                
                ProdQ:GetPredictionAfterImmobile(hero, AfterImmobileFunc, false)
            end
                        

            
            if Menu.ProdSettings.OI then
                ProdR:GetPredictionOnImmobile(hero, OnImmobileFunc)
            else
                ProdR:GetPredictionOnImmobile(hero, OnImmobileFunc, false)
            end

        end
    end
    OnDashPos = nil
    AfterDashPos = nil
    AfterImmobilePos = nil
    OnImmobilePos = nil
 
  if Menu.Ads.NOVA then
		for i = 1, heroManager.iCount do
			local hero = heroManager:GetHero(i)
			local radius = skills.SkillE.range + VP:GetHitBox(hero)
			if hero.team ~= myHero.team and objE ~= nil and ValidTarget(hero) and GetDistanceSqr(objE,hero) <= radius * radius then
				CastSpell(_E)
			end
		end
	end
  
    
	if Menu.Ads.autoLevel then
		AutoLevel()
	end
	
	if Menu.luxCombo.combo and Menu.ProdSettings.SelectProdiction == 2 then
		Combo()
  elseif Menu.luxCombo.combo and Menu.ProdSettings.SelectProdiction == 1 then
    ProdictionCombo()
	end
	
	if Menu.Harass.harass then
		Harass()
	end
	
	if Menu.Laneclear.lclr then
		LaneClear()
	end
	
	if Menu.Jungleclear.jclr then
		JungleClear()
	end
  if GetGame().isOver then
	UpdateWeb(false, ScriptName, id, HWID)
	-- This is a var where I stop executing what is in my OnTick()
	startUp = false;
end

end


function ProdictionCombo()
  if target ~= nil and target.type == myHero.type then
    for i, target in ipairs(GetEnemyHeroes()) do
		rDmg = getDmg("R", target, myHero)
    if  Menu.luxCombo.qSet.useQ and Menu.ProdSettings.SelectProdiction == 1 then
        if ValidTarget(target) then
                    ProdQ:GetPredictionCallBack(target, CastQ)
        end
    end
    if  Menu.luxCombo.eSet.useE and Menu.ProdSettings.SelectProdiction == 1 then
        if ValidTarget(target) then
                    ProdE:GetPredictionCallBack(target, CastE)
        end
    end
    if  Menu.luxCombo.rSet.useR and Menu.ProdSettings.SelectProdiction == 1 then
      
        if ValidTarget(target) and target.health < rDmg then
                    ProdR:GetPredictionCallBack(target, CastR)
                  
        end
    end
  end
end
end

function CDHandler()
	-- Spells
	Qready = (myHero:CanUseSpell(_Q) == READY)
	Wready = (myHero:CanUseSpell(_W) == READY)
	Eready = (myHero:CanUseSpell(_E) == READY)
	Rready = (myHero:CanUseSpell(_R) == READY)

	-- Items
	tiamatSlot = GetInventorySlotItem(3077)
	hydraSlot = GetInventorySlotItem(3074)
	youmuuSlot = GetInventorySlotItem(3142) 
	bilgeSlot = GetInventorySlotItem(3144)
	bladeSlot = GetInventorySlotItem(3153)
	dfgSlot = GetInventorySlotItem(3128)
	divineSlot = GetInventorySlotItem(3131)
	
	tiamatReady = (tiamatSlot ~= nil and myHero:CanUseSpell(tiamatSlot) == READY)
	hydraReady = (hydraSlot ~= nil and myHero:CanUseSpell(hydraSlot) == READY)
	youmuuReady = (youmuuSlot ~= nil and myHero:CanUseSpell(youmuuSlot) == READY)
	bilgeReady = (bilgeSlot ~= nil and myHero:CanUseSpell(bilgeSlot) == READY)
	bladeReady = (bladeSlot ~= nil and myHero:CanUseSpell(bladeSlot) == READY)
	dfgReady = (dfgSlot ~= nil and myHero:CanUseSpell(dfgSlot) == READY)
	divineReady = (divineSlot ~= nil and myHero:CanUseSpell(divineSlot) == READY)

	-- Summoners
	if myHero:GetSpellData(SUMMONER_1).name:find("SummonerDot") then
		ignite = SUMMONER_1
	elseif myHero:GetSpellData(SUMMONER_2).name:find("SummonerDot") then
		ignite = SUMMONER_2
	end
	igniteReady = (ignite ~= nil and myHero:CanUseSpell(ignite) == READY)
end

-- Harass functie--

function Harass()	
	if target ~= nil and ValidTarget(target) then
    if Menu.ProdSettings.SelectProdiction == 2 then
		if Menu.Harass.useQ and ValidTarget(target, skills.SkillQ.range) and Qready then
			CastSpell(_Q, ts.target.x, ts.target.z)
		end
    end
    if Menu.ProdSettings.SelectProdiction == 2 and Menu.Harass.useE and ValidTarget(target, skills.SkillE.range) and Eready then
			CastSpell(_E, ts.target.x, ts.target.z)
		end
    if Menu.ProdSettings.SelectProdiction == 1 and ValidTarget(target, skills.SkillQ.range) and Qready then
      ProdQ:GetPredictionCallBack(target, CastQ)
    end
    if Menu.ProdSettings.SelectProdiction == 1 and ValidTarget(target, skills.SkillE.range) and Eready then
      ProdE:GetPredictionCallBack(target, CastE)
    end
      
      
      
	end
end


-- auto Q
function OnGapclose(target)
  if target ~= nil then
    
    local CastPosition,  HitChance,  Position = VP:GetCircularCastPosition(target, skills.SkillQ.delay, skills.SkillQ.width, skills.SkillQ.range, skills.SkillQ.speed, myHero, true)
          if Qready and  Menu.Ads.KS.autoQ and  HitChance >= 2 and GetDistance(CastPosition) < 300 then
            CastSpell(_Q, CastPosition.x, CastPosition.z)
          end
         
            
		
	end
end

-- Combo herkenbaar--

function Combo()
	local typeCombo = 0
	if target ~= nil then
		AllInCombo(target, 0)
	end
end

      

function AllInCombo(target, typeCombo)
	if target ~= nil and typeCombo == 0 then
		ItemUsage(target)
    if Menu.ProdSettings.SelectProdiction == 2 then
      if Menu.luxCombo.qSet.useQ and ValidTarget(target, skills.SkillQ.range) and Qready then
			local CastPosition, HitChance, Position = VP:GetLineCastPosition(target, skills.SkillQ.delay, skills.SkillQ.width, skills.SkillQ.range, skills.SkillQ.speed, myHero, true)
            if HitChance >= 2 and GetDistance(CastPosition) < 1050 then
				CastSpell(_Q, CastPosition.x, CastPosition.z)
            end
    end
    end
      	
        if Menu.ProdSettings.SelectProdiction == 2 then
		   if Menu.luxCombo.eSet.useE and ValidTarget(target, skills.SkillE.range) and Eready then
local CastPosition, HitChance, Position = VP:GetCircularCastPosition(target, skills.SkillE.delay, skills.SkillE.width, skills.SkillE.range, skills.SkillE.speed, myHero, false)
            if HitChance >= 2 and GetDistance(CastPosition) < 1100 then
              CastSpell(_E, CastPosition.x, CastPosition.z)
            end
        end
   end
end

end
-- All In Combo --




function LaneClear()
	for i, minion in pairs(targetMinions.objects) do
		if minion ~= nil then
			if Menu.Laneclear.useClearQ and Qready and ValidTarget(minion, skills.SkillQ.range)then
				local qPosition, qChance = VP:GetCircularCastPosition(minion, skills.SkillQ.delay, skills.SkillQ.width, skills.SkillQ.range, skills.SkillQ.speed, myHero, false)
			    if qPosition ~= nil and qChance >= 2 then
			      CastSpell(_Q, qPosition.x, qPosition.z)
			    end
      end
      if Menu.Laneclear.useClearE and Eready and ValidTarget(minion, skills.SkillE.range)then
				local ePosition, eChance = VP:GetCircularCastPosition(minion, skills.SkillE.delay, skills.SkillE.width, skills.SkillE.range, skills.SkillE.speed, myHero, false)
			    if ePosition ~= nil and eChance >= 2 then
			      CastSpell(_E, ePosition.x, ePosition.z)
          end
      end
    end
  end
end

function JungleClear()
	for i, jungleMinion in pairs(jungleMinions.objects) do
		if jungleMinion ~= nil then
			if Menu.Jungleclear.useClearQ and Qready and ValidTarget(jungleMinion, skills.SkillQ.range) then
				CastSpell(_Q, jungleMinion)
			end
			if Menu.Jungleclear.useClearE and Eready and ValidTarget(jungleMinion, skills.SkillE.range) then
				CastSpell(_W, jungleMinion)
			end
		end
	end
end

function AutoLevel()
	local qL, wL, eL, rL = player:GetSpellData(_Q).level + qOff, player:GetSpellData(_W).level + wOff, player:GetSpellData(_E).level + eOff, player:GetSpellData(_R).level + rOff
	if qL + wL + eL + rL < player.level then
		local spellSlot = { SPELL_1, SPELL_2, SPELL_3, SPELL_4, }
		local level = { 0, 0, 0, 0 }
		for i = 1, player.level, 1 do
			level[abilitySequence[i]] = level[abilitySequence[i]] + 1
		end
		for i, v in ipairs({ qL, wL, eL, rL }) do
			if v < level[i] then LevelSpell(spellSlot[i]) end
		end
	end
end

function KillSteal()
  if Menu.Ads.KS.useR then
		hardeultiKS()
	end
  if Menu.Ads.KS.useE then
    hardeKSE()
  end
	if Menu.Ads.KS.ignite then
		IgniteKS()
  end
  if Menu.Ads.KS.KSB then
    KSBUFF()
  end
  if Menu.Ads.Shield then
    AutoShield()
  end
  if Menu.Ads.KS.useQ then
     hardeKSQ()
  end
end

-- Auto Ignite get the maximum range to avoid over kill --

function IgniteKS()
	if igniteReady then
		local Enemies = GetEnemyHeroes()
		for i, val in ipairs(Enemies) do
			if ValidTarget(val, 600) then
				if getDmg("IGNITE", val, myHero) > val.health and GetDistance(val) >= Menu.Ads.KS.igniteRange then
					CastSpell(ignite, val)
				end
			end
		end
	end
end


-- ks ulti
function hardeultiKS()
  if target ~= nil and target.type ==  myHero.type then
	for i, target in ipairs(GetEnemyHeroes()) do
		rDmg = getDmg("R", target, myHero)
    local RDamage = (GetRDamage() + (myHero.ap*0.75))
    --print(rDmg)
    

		if Menu.ProdSettings.SelectProdiction == 2 and Rready and target ~= nil and ValidTarget(target, skills.SkillR.range) and target.health < RDamage then
      local CastPosition,  HitChance,  Position = VP:GetCircularCastPosition(target, skills.SkillR.delay, skills.SkillR.width, skills.SkillR.range, skills.SkillR.speed, myHero, false)
            if HitChance >= 2 and GetDistance(CastPosition) < 3300 then
				CastSpell(_R, CastPosition.x, CastPosition.z)
        
        end
      end
      if Menu.ProdSettings.SelectProdiction == 1 and Rready and ValidTarget(target) and target.health < RDamage then 
        ProdR:GetPredictionCallBack(target, CastR)
        --print(RDamage)
        
      
      
    end
  end
  
end
end
-- ks E

function hardeKSE()
  if target ~= nil and target.type == myHero.type then
  for i, target in ipairs(GetEnemyHeroes()) do
    eDmg = getDmg("E", target, myHero)
    if Eready and target ~= nil and ValidTarget(target, skills.SkillE.range) and target.health < eDmg then
      if Menu.ProdSettings.SelectProdiction == 2 then
        --print("niet") 
        if Menu.luxCombo.eSet.useE and ValidTarget(target, skills.SkillE.range) and Eready then
        local CastPosition, HitChance, Position = VP:GetCircularCastPosition(target, skills.SkillE.delay, skills.SkillE.width, skills.SkillE.range, skills.SkillE.speed, myHero, false)
          if HitChance >= 2 and GetDistance(CastPosition) < 1100 then
              CastSpell(_E, CastPosition.x, CastPosition.z)
          end
        end
      elseif Menu.ProdSettings.SelectProdiction == 1 then
        --print("ewl") 
        ProdE:GetPredictionCallBack(target, CastE)
      end
      
end
end
end 
end

function hardeKSQ()
 -- print("603") 
  if target ~= nil and target.type == myHero.type then
     --print("605")
    
  for i, target in ipairs(GetEnemyHeroes()) do
    qDmg = getDmg("Q", target, myHero)
    --print("609")
    if skills.SkillQ.ready and target ~= nil and ValidTarget(target, skills.SkillQ.range) and target.health < qDmg then
       --print("610")
      if Menu.ProdSettings.SelectProdiction == 2 then
        if Menu.luxCombo.qSet.useQ and ValidTarget(target, skills.SkillQ.range) and Qready then
        local CastPosition, HitChance, Position = VP:GetCircularCastPosition(target, skills.SkillQ.delay, skills.SkillQ.width, skills.SkillQ.range, skills.SkillQ.speed, myHero, false)
          if HitChance >= 2 and GetDistance(CastPosition) < 1100 then
              CastSpell(_Q, CastPosition.x, CastPosition.z)
          end
        end
      elseif Menu.ProdSettings.SelectProdiction == 1 then
        --print("616") 
        ProdQ:GetPredictionCallBack(target, CastQ)
      end
      
end
end
end 
end
-- Auto Ignite --

function HealthCheck(unit, HealthValue)
	if unit.health > (unit.maxHealth * (HealthValue/100)) then 
		return true
	else
		return false
	end
end

function ItemUsage(target)

	if dfgReady then CastSpell(dfgSlot, target) end
	if youmuuReady then CastSpell(youmuuSlot, target) end
	if bilgeReady then CastSpell(bilgeSlot, target) end
	if bladeReady then CastSpell(bladeSlot, target) end
	if divineReady then CastSpell(divineSlot, target) end

end

-- Change skin function, made by Shalzuth
function GenModelPacket(champ, skinId)
	p = CLoLPacket(0x97)
	p:EncodeF(myHero.networkID)
	p.pos = 1
	t1 = p:Decode1()
	t2 = p:Decode1()
	t3 = p:Decode1()
	t4 = p:Decode1()
	p:Encode1(t1)
	p:Encode1(t2)
	p:Encode1(t3)
	p:Encode1(bit32.band(t4,0xB))
	p:Encode1(1)--hardcode 1 bitfield
	p:Encode4(skinId)
	for i = 1, #champ do
		p:Encode1(string.byte(champ:sub(i,i)))
	end
	for i = #champ + 1, 64 do
		p:Encode1(0)
	end
	p:Hide()
	RecvPacket(p)
end

function skinChanged()
	return Menu.Ads.VIP.skin1 ~= lastSkin
end

function DrawCircleNextLvl(x, y, z, radius, width, color, chordlength)
 radius = radius or 300
 quality = math.max(8,math.floor(180/math.deg((math.asin((chordlength/(2*radius)))))))
 quality = 2 * math.pi / quality
 radius = radius*.92
 local points = {}
 for theta = 0, 2 * math.pi + quality, quality do
  local c = WorldToScreen(D3DXVECTOR3(x + radius * math.cos(theta), y, z - radius * math.sin(theta)))
  points[#points + 1] = D3DXVECTOR2(c.x, c.y)
 end
 DrawLines2(points, width or 1, color or 4294967295)
end

function DrawCircle2(x, y, z, radius, color)
 local vPos1 = Vector(x, y, z)
 local vPos2 = Vector(cameraPos.x, cameraPos.y, cameraPos.z)
 local tPos = vPos1 - (vPos1 - vPos2):normalized() * radius
 local sPos = WorldToScreen(D3DXVECTOR3(tPos.x, tPos.y, tPos.z))
 if OnScreen({ x = sPos.x, y = sPos.y }, { x = sPos.x, y = sPos.y })  then
  self:DrawCircleNextLvl(x, y, z, radius, 1, color, 75)
 end
end

function CircleDraw(x,y,z,radius, color)
	self:DrawCircle2(x, y, z, radius, color)
end--[[ Kill Text ]]--
TextList = {"Harass him", "Q", "W", "E", "ULT HIM !", "Items", "All In", "Skills Not Ready"}
KillText = {}
colorText = ARGB(229,229,229,0)
_G.ShowTextDraw = true

-- Damage Calculation Thanks Skeem for the base --

  


function DamageCalculation()
  for i=1, heroManager.iCount do
    local enemy = heroManager:GetHero(i)
    if ValidTarget(enemy) and enemy ~= nil then
      qDmg = getDmg("Q", enemy,myHero)
      wDmg = getDmg("W", enemy,myHero)
      eDmg = getDmg("E", enemy,myHero)
      rDmg = getDmg("R", enemy,myHero)
      dfgDmg = getDmg("DFG", enemy, myHero)


      if not Qready and not Wready and not Eready and not Rready then
        KillText[i] = TextList[8]
        return
      end

      if enemy.health <= qDmg then
        KillText[i] = TextList[2]
      elseif enemy.health <= wDmg then
        KillText[i] = TextList[3]
      elseif enemy.health <= eDmg then
        KillText[i] = TextList[4]
      elseif enemy.health <= rDmg then
        KillText[i] = TextList[5]
      elseif enemy.health <= qDmg + wDmg then
        KillText[i] = TextList[2] .."+".. TextList[3]
      elseif enemy.health <= qDmg + eDmg then
        KillText[i] = TextList[2] .."+".. TextList[4]
      elseif enemy.health <= qDmg + rDmg then
        KillText[i] = TextList[2] .."+".. TextList[5]
      elseif enemy.health <= wDmg + eDmg then
        KillText[i] = TextList[3] .."+".. TextList[4]
      elseif enemy.health <= wDmg + rDmg then
        KillText[i] = TextList[3] .."+".. TextList[5]
      elseif enemy.health <= eDmg + rDmg then
        KillText[i] = TextList[4] .."+".. TextList[5]
      elseif enemy.health <= qDmg + wDmg + eDmg then
        KillText[i] = TextList[2] .."+".. TextList[3] .."+".. TextList[4]
      elseif enemy.health <= qDmg + wDmg + eDmg + rDmg then
        KillText[i] = TextList[2] .."+".. TextList[3] .."+".. TextList[4] .."+".. TextList[5]
      elseif enemy.health <= dfgDmg + ((qDmg + wDmg + eDmg + rDmg) + (0.2 * (qDmg + wDmg + eDmg + rDmg))) then
        KillText[i] = TextList[7]
      else
        KillText[i] = TextList[1]
      end
    end
  end
end

function OnDraw()    if not myHero.dead then
        if Menu.drawings.drawAA then DrawCircle(myHero.x, myHero.y, myHero.z, Ranges.AA, ARGB(25 , 125, 125, 125)) end
        if Menu.drawings.drawQ then DrawCircle(myHero.x, myHero.y, myHero.z, skills.SkillQ.range, ARGB(25 , 125, 125, 125)) end
        if Menu.drawings.drawW then DrawCircle(myHero.x, myHero.y, myHero.z, skills.SkillW.range, ARGB(25 , 125, 125, 125)) end
        if Menu.drawings.drawE then DrawCircle(myHero.x, myHero.y, myHero.z, skills.SkillE.range, ARGB(25 , 125, 125, 125)) end
        if Menu.drawings.drawR then DrawCircle(myHero.x, myHero.y, myHero.z, skills.SkillR.range, ARGB(25 , 125, 125, 125)) end
    end
if _G.ShowTextDraw then
    for i = 1, heroManager.iCount do
	    local enemy = heroManager:GetHero(i)
	    if ValidTarget(enemy) and enemy ~= nil then
	      local barPos = WorldToScreen(D3DXVECTOR3(enemy.x, enemy.y, enemy.z)) --(Credit to Zikkah)
	      local PosX = barPos.x - 35
	      local PosY = barPos.y - 10
	      if KillText[i] ~= 10 then
	        DrawText(TextList[KillText[i]], 16, PosX, PosY, colorText)
	      else
	        DrawText(TextList[KillText[i]] .. string.format("%4.1f", ((enemy.health - (qDmg + pDmg + eDmg + itemsDmg)) * (1/rDmg)) * 2.5) .. "s = Kill", 16, PosX, PosY, colorText)
	      end
	    end
	end
  end
end






-- Steal the jungle mobs whit R Copyright!
local JungleMobs = {}
local JungleFocusMobs = {}





--Moet 
local JungleMobNames = { 
        ["AncientGolem7.1.1"] = true,
        ["LizardElder10.1.1"] = true,
         ["Dragon6.1.1"] = true,
        ["Worm12.1.1"] = true,
      --  ["wolf8.1.1"] = true,
       -- ["wolf8.1.2"] = true,
        --["YoungLizard7.1.2"] = true,
       -- ["YoungLizard7.1.3"] = true,
       -- ["LesserWraith9.1.1"] = true,
     --   ["LesserWraith9.1.2"] = true,
       -- ["LesserWraith9.1.4"] = true,
       -- ["YoungLizard10.1.2"] = true,
     --   ["YoungLizard10.1.3"] = true,
     --   ["SmallGolem11.1.1"] = true,
     --   ["wolf2.1.1"] = true,
    --    ["wolf2.1.2"] = true,
   ---     ["YoungLizard1.1.2"] = true,
    --  -  ["YoungLizard1.1.3"] = true,
     --   ["LesserWraith3.1.1"] = true,
     --   ["LesserWraith3.1.2"] = true,
   --    ["LesserWraith3.1.4"] = true,
   --     ["YoungLizard4.1.2"] = true,
    --   ["YoungLizard4.1.3"] = true,
      --  ["SmallGolem5.1.1"] = true,
}

local FocusJungleNames = {
        ["Dragon6.1.1"] = true,
        ["Worm12.1.1"] = true,
      --  ["GiantWolf8.1.1"] = true,
       -- ["AncientGolem7.1.1"] = true,
      --  ["Wraith9.1.1"] = true,
      --  ["LizardElder10.1.1"] = true,
      --  ["Golem11.1.2"] = true,
     --   ["GiantWolf2.1.1"] = true,
        ["AncientGolem1.1.1"] = true,
     --   ["Wraith3.1.1"] = true,
        ["LizardElder4.1.1"] = true,
     --   ["Golem5.1.2"] = true,
		--["GreatWraith13.1.1"] = true,
	--	["GreatWraith14.1.1"] = true,
}



function GetJungleMob()
	if JungleFocusMobs ~= nil and #JungleFocusMobs > 0 and player.team == TEAM_RED then
        for i, Mob in ipairs(JungleFocusMobs) do
                if ValidTarget(Mob, 3300) and Mob.name ~= nil then return Mob end
        end
    elseif JungleMobs ~= nil and #JungleMobs > 0 and player.team == TEAM_BLUE then
        for i, Mob in ipairs(JungleMobs) do
           if ValidTarget(Mob, 3300) and Mob.name ~= nil then return Mob end
        end
    else
    	return nil
    end
end

function OnCreateObj(obj)
  if obj.name:find("LuxLightstrike_tar_green") then
		objE = obj
	end
	if obj ~= nil then
		if FocusJungleNames[obj.name] and player.team == TEAM_RED then
			table.insert(JungleFocusMobs, obj)
		elseif JungleMobNames[obj.name] and player.team == TEAM_BLUE  then
            table.insert(JungleMobs, obj)
		end
	end
	if obj ~= nil and obj.type == "obj_AI_Minion" and obj.name ~= nil then
    if player.team == TEAM_RED then
 
		if obj.name == "Worm12.1.1" then Nashor = obj
		elseif obj.name == "Dragon6.1.1" then Dragon = obj
		elseif obj.name == "AncientGolem1.1.1" then Golem1 = obj
    elseif obj.name == "LizardElder4.1.1" then Lizard1 = obj end
  elseif player.team == TEAM_BLUE then
    if obj.name == "Worm12.1.1" then Nashor = obj
		elseif obj.name == "Dragon6.1.1" then Dragon = obj
		elseif obj.name == "AncientGolem7.1.1" then Golem2 = obj
    elseif obj.name == "LizardElder10.1.1" then Lizard2 = obj end
    
  
	end
end
end

function OnDeleteObj(obj)
  if obj.name:find("LuxLightstrike_tar_green") or (objE ~= nil and obj.name == objE.name) then
		objE = nil
	end
	if obj ~= nil then
		for i, Mob in ipairs(JungleMobs) do
			if obj.name == Mob.name then
				table.remove(JungleMobs, i)
			end
		end
		for i, Mob in ipairs(JungleFocusMobs) do
			if obj.name == Mob.name then
				table.remove(JungleFocusMobs, i)
			end
		end
	end
	if obj ~= nil and obj.name ~= nil then
		if obj.name == "TT_Spiderboss7.1.1" then Vilemaw = nil
		elseif obj.name == "Worm12.1.1" then Nashor = nil
		elseif obj.name == "Dragon6.1.1" then Dragon = nil
		elseif obj.name == "AncientGolem1.1.1" then Golem1 = nil
		elseif obj.name == "AncientGolem7.1.1" then Golem2 = nil
		elseif obj.name == "LizardElder4.1.1" then Lizard1 = nil
		elseif obj.name == "LizardElder10.1.1" then Lizard2 = nil end
	end
end

function checkDeadMonsters()
	if Vilemaw ~= nil then if not Vilemaw.valid or Vilemaw.dead or Vilemaw.health <= 0 then Vilemaw = nil end end
	if Nashor ~= nil then if not Nashor.valid or Nashor.dead or Nashor.health <= 0 then Nashor = nil end end
	if Dragon ~= nil then if not Dragon.valid or Dragon.dead or Dragon.health <= 0 then Dragon = nil end end
	if Golem1 ~= nil then if not Golem1.valid or Golem1.dead or Golem1.health <= 0 then Golem1 = nil end end
	if Golem2 ~= nil then if not Golem2.valid or Golem2.dead or Golem2.health <= 0 then Golem2 = nil end end
	if Lizard1 ~= nil then if not Lizard1.valid or Lizard1.dead or Lizard1.health <= 0 then Lizard1 = nil end end
	if Lizard2 ~= nil then if not Lizard2.valid or Lizard2.dead or Lizard2.health <= 0 then Lizard2 = nil end end
end

--- wauw


function KSBUFF()
	TargetJungleMob = GetJungleMob()
  local RDamage = (GetRDamage() + (myHero.ap*0.75))
	if TargetJungleMob ~= nil and ValidTarget(TargetJungleMob, 3300) and GetDistance(TargetJungleMob, myHero) < 3300 then
			if Rready and TargetJungleMob.health < RDamage  then
				CastSpell(_R, TargetJungleMob.x, TargetJungleMob.z)
       
			end
			
	end
end

function ASLoadMinions()
	for i = 1, objManager.maxObjects do
		local obj = objManager:getObject(i)
		if obj ~= nil and obj.type == "obj_AI_Minion" and obj.name ~= nil then
			if obj.name == "TT_Spiderboss7.1.1" then Vilemaw = obj
			elseif obj.name == "Worm12.1.1" then Nashor = obj
			elseif obj.name == "Dragon6.1.1" then Dragon = obj
			elseif obj.name == "AncientGolem1.1.1" then Golem1 = obj
			elseif obj.name == "AncientGolem7.1.1" then Golem2 = obj
			elseif obj.name == "LizardElder4.1.1" then Lizard1 = obj
			elseif obj.name == "LizardElder10.1.1" then Lizard2 = obj end
		end
	end
	for i = 0, objManager.maxObjects do
		local object = objManager:getObject(i)
		if object ~= nil and object.type == "obj_AI_Minion" and object.name ~= nil then
			if FocusJungleNames[object.name] and player.team == TEAM_RED then
				table.insert(JungleFocusMobs, object)
			elseif JungleMobNames[object.name] and player.team == TEAM_BLUE then
				table.insert(JungleMobs, object)
			end
		end
	end
end

local injectedd = false
local mostDamage = 0
local lowestHealth = math.huge
function AutoShield()
	if injectedd and Wready then
		--Find really low health guy
		for i=1, heroManager.iCount do
			local ally = heroManager:getHero(i)
			if ally.health < lowestHealth and ally.team ~= TEAM_ENEMY and GetDistance(myHero, ally) < 1100 and Wready then
				lowGuy = ally
				lowestHealth = ally.health
			end
		end
		if Wready and lowGuy ~= nil and GetDistance(myHero, ally) < 1100 and lowGuy ~= myHero and lowGuy.maxHealth * .16 >= lowGuy.health then 
			CastSpell(_W, lowGuy) 
     
		end

		--Omg is the low health person me?
		if myHero.maxHealth * .05 >= myHero.health and Wready then
			CastSpell(_W, myHero)
    
		end

		--Find ADC
		for i=1, heroManager.iCount do
			local ally = heroManager:getHero(i)
			if ally.totalDamage > mostDamage and ally.team ~= TEAM_ENEMY and GetDistance(myHero, ally) < 1100 and Wready then
				ADC = ally
				mostDamage = ally.totalDamage
			end
		end
		if Wready and ADC ~= nil and GetDistance(myHero, ally) < 1100 and ADC ~= myHero then 
			CastSpell(_W, ADC) 
      
		end
	end
end
local typeshield
local spellslot
local range = 0
local Shield = false
local ally = nil
 
 -- voor laterlocal dmgpercent = skilldamage*100/target.health
--	local dmgneeded = dmgpercent >= configused.mindmgpercent
	--local hpneeded = configused.maxhppercent >= (target.health-skilldamage)*100/target.maxHealth
function OnProcessSpell(object, spell)
  if object.team ~= myHero.team and not myHero.dead and not object.name:find("Minion_") or object.name:find("Odin") then
    local shieldREADY = typeshield ~= nil and myHero:CanUseSpell(spellslot) == READY
    local RaakEest = false -- dit was eerst hitfirst
    local shieldtarget,SlastDistance,SLastDmgPercent = nil,nil,nil
      BShield,SShield,shield,CC = false,false,false,false
      local shottype,radius,masdistance = 0,0,0
        if object.type =="AIHeroClient" then
          spelltype, casttype = getSpellType(object, spell.name)
          if spelltype == "BAttack" or spelltype == "CAttack" then
            Shield = false
          elseif spell.name:find("SummonerDot") then
           
           Shield = true
          elseif spelltype =="Q" or spelltype == "W" or spelltype == "R" or spelltype == "E" or spelltype == "P" or spelltype == "QM" or spelltype == "WM" or spelltype == "EM" then
           Shield = true
           
            if Shield and Menu.Ads.Shieldd then
                if Wready and target ~= nil and ValidTarget(target, skills.SkillW.range) then
    CastSpell(_W, target.x, target.z)


                  
                end
            end
          end
        end
  end
  end



  function OnBugsplat()
	UpdateWeb(false, ScriptName, id, HWID)
end

function OnUnload()
	UpdateWeb(false, ScriptName, id, HWID)
end

function GetQPos(unit, pos)
        qPos = pos
end
function GetEPos(unit, pos)
        ePos = pos
end
function GetRPos(unit, pos)
        rPos = pos
end
function CastQ(unit,pos)
    if GetDistance(pos) < skills.SkillQ.range and skills.SkillQ.ready then
        local coll = Collision(1150, 1175, 0.25, 80)
            if not coll:GetMinionCollision(pos, myHero) then
                CastSpell(_Q, pos.x, pos.z)
            end
    end
end

function CastE(unit,pos)
    if target ~= nil then 
      if GetDistance(pos) < skills.SkillE.range and skills.SkillE.ready then
   
                CastSpell(_E, pos.x, pos.z)
            end
    end
end
function CastR(unit,pos)
  for i, target in ipairs(GetEnemyHeroes()) do
		rDmg = getDmg("R", target, myHero)
    eDmg = getDmg("E", target, myHero)
    if Menu.luxCombo.combo or Menu.Ads.KS.useR then
      if GetDistance(pos) < skills.SkillR.range and skills.SkillR.ready and target.health < rDmg then
        CastSpell(_R, pos.x, pos.z)

      end
    end
  end
end

----- afther dash 3 x

function AfterDashFunc(unit, pos, spell)

 if GetDistance(pos) < skills.SkillQ.range and skills.SkillQ.ready then
        local collition = Collision(1150, 1175, 0.25, 80)
        if not collition:GetMinionCollision(pos, myHero) then
            CastSpell(_Q, pos.x, pos.z)
        end
 end


end




------------------- 3 x maar gewoon
function AfterImmobileFunc(unit, pos, spell)

 if GetDistance(pos) < skills.SkillQ.range and skills.SkillQ.ready then
        local collition = Collision(1150, 1175, 0.25, 80)
        if not collition:GetMinionCollision(pos, myHero) then
            CastSpell(_Q, pos.x, pos.z)
        
        end
 end
end


------ ook maar 3 x dan


function OnImmobileFunc(unit, pos, spell)

 if GetDistance(pos) < skills.SkillR.range and skills.SkillR.ready then
        local collition = Collision(3340, math.huge, 0.70, 190)
        if not collition:GetMinionCollision(pos, myHero) then
            CastSpell(_R, pos.x, pos.z)
     
  
        end
 end
end



function RDamage()
  if target ~= nil then
  if skills.SkillR.ready then
    local Kipje = myHero:CalcMagicDamage(target, 100)
   
    --MAGIC DAMAGE: 300 / 400 / 500 (+ 75% AP)
     
    
    --print(Kipje)
end
end
end
function GetRDamage()
        if myHero:GetSpellData(_R).level == 1 then
                return 300
        elseif myHero:GetSpellData(_R).level == 2 then
                return 400
        elseif myHero:GetSpellData(_R).level == 3 then
                return 500
        end
end
